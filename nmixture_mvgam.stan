// Stan model code generated by package mvgam
functions {
  // added functions //
  /**
   * Return log probability of Poisson Binomial Mixture
   *
   * @param count      Observed count
   * @param k          Latent population size
   * @param lambda     Poisson mean on log scale
   * @param p          Detection probability on logit scale
   *
   * @return Log probability
   */
  real poisbin_lpmf(int count, int k, real lambda, real p) {
    if (count > k) {
      return negative_infinity();
    }
    return poisson_log_lpmf(k | lambda) + binomial_logit_lpmf(count | k, p);
  }

   /**
   * Return log probability of N-mixture model for a site
   *
   * @param count    Count in a site
   * @param max_k    Maximum site-abundance
   * @param lambda   Mean site-abundance on log scale
   * @param p        Per capita detection probability on logit scale
   *
   * @return         Log probability
   */

  vector pb_logp(int count, int max_k,
                 real lambda, real p) {

    vector[max_k + 1] lp;

    for (k in 0:(count - 1))
      lp[k + 1] = negative_infinity();
    for (k in count:max_k)
      lp[k + 1] = poisbin_lpmf(count | k, lambda, p);
    return lp;
  }

  real pb_lpmf(int count, int max_k,
               real lambda, real p) {

    vector[max_k + 1] lp;
    lp = pb_logp(count, max_k, lambda, p);

    return log_sum_exp(lp);

  }
}
data {
  int<lower=0> total_obs; // total number of observations
  int<lower=0> n; // number of timepoints per series
  int<lower=0> n_sp_trend; // number of trend smoothing parameters
  int<lower=0> n_lv; // number of dynamic factors
  int<lower=0> n_series; // number of series
  matrix[n_series, n_lv] Z; // matrix mapping series to latent states
  int<lower=0> num_basis; // total number of basis coefficients
  int<lower=0> num_basis_trend; // number of trend basis coefficients
  vector[num_basis_trend] zero_trend; // prior locations for trend basis coefficients
  matrix[total_obs, num_basis] X; // mgcv GAM design matrix
  matrix[n * n_lv, num_basis_trend] X_trend; // trend model design matrix
  int<lower=0> ytimes[n, n_series]; // time-ordered matrix (which col in X belongs to each [time, series] observation?)
  int<lower=0> ytimes_trend[n, n_lv]; // time-ordered matrix for latent states
  int<lower=0> n_nonmissing; // number of nonmissing observations
  matrix[7,14] S_trend1; // mgcv smooth penalty matrix S_trend1
  int<lower=0> flat_ys[n_nonmissing]; // flattened nonmissing observations
  matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations
  int<lower=0> obs_ind[n_nonmissing]; // indices of nonmissing observations

  // added data lines //
  int<lower=0> cap[n_nonmissing]; // upper limits of latent abundances
}
transformed data {
}
parameters {
  // raw basis coefficients
  vector[num_basis] b_raw;
  vector[num_basis_trend] b_raw_trend;

  // latent state SD terms
  vector<lower=0>[n_lv] sigma;

  // latent state AR1 terms
  vector<lower=-1.5,upper=1.5>[n_lv] ar1;

  // latent states
  matrix[n, n_lv] LV;

  // smoothing parameters
  vector<lower=0>[n_sp_trend] lambda_trend;
}
transformed parameters {
  // add detection probability parameter //
  vector[total_obs] p;

  // latent states and loading matrix
  vector[n * n_lv] trend_mus;
  matrix[n, n_series] trend;
  matrix[n_series, n_lv] lv_coefs;

  // basis coefficients
  vector[num_basis] b;
  vector[num_basis_trend] b_trend;

  // observation model basis coefficients
  b[1:num_basis] = b_raw[1:num_basis];

  // process model basis coefficients
  b_trend[1:num_basis_trend] = b_raw_trend[1:num_basis_trend];

  // latent process linear predictors
  trend_mus = X_trend * b_trend;

  // derived latent states
  lv_coefs = Z;
  for (i in 1:n){
    for (s in 1:n_series){
      trend[i, s] = dot_product(lv_coefs[s,], LV[i,]);
    }
  }

  // add detection probability model //
  p = X * b;
}
model {
  // changed prior for avg det prob //
  // prior for (Intercept)...
  b_raw[1] ~ std_normal();

  // changed prior for rainfall //
  // prior for rainfall...
  b_raw[2] ~ std_normal();

  // priors for AR parameters
  ar1 ~ std_normal();

  // priors for latent state SD parameters
  sigma ~ student_t(3, 0, 2.5);

  // dynamic process models

  // prior for s(temperature)_trend...
  b_raw_trend[1:7] ~ multi_normal_prec(zero_trend[1:7],S_trend1[1:7,1:7] * lambda_trend[1] + S_trend1[1:7,8:14] * lambda_trend[2]);
  lambda_trend ~ normal(5, 30);
  for(j in 1:n_lv){
    LV[1, j] ~ normal(trend_mus[ytimes_trend[1, j]], sigma[j]);
    for(i in 2:n){
      LV[i, j] ~ normal(trend_mus[ytimes_trend[i, j]] + ar1[j] * (LV[i - 1, j] - trend_mus[ytimes_trend[i - 1, j]]), sigma[j]);
    }
  }

  {
    // likelihood functions
    vector[n_nonmissing] flat_trends;
    vector[n_nonmissing] flat_ps;
    flat_trends = (to_vector(trend))[obs_ind];
    flat_ps = p[obs_ind];
    for (i in 1:n_nonmissing){
      target += pb_lpmf(flat_ys[i] | cap[i], flat_trends[i], p[i]);
    }
  }
}
generated quantities {
  vector[total_obs] eta;
  matrix[n, n_series] mus;
  vector[n_sp_trend] rho_trend;
  vector[n_lv] penalty;
  array[n, n_series] int ypred;
  // add predictions for latent abundance //
  array[n, n_series] int latent_ypred;
  // add detection prob //
  vector[total_obs] detprob;
  detprob = inv_logit(p);
  penalty = 1.0 / (sigma .* sigma);
  rho_trend = log(lambda_trend);

  // posterior predictions
  eta = X * b;
  for(s in 1:n_series){
    // true latent abundance
    latent_ypred[1:n, s] = poisson_log_rng(trend[1:n, s]);
    // observed abundance
    ypred[1:n, s] = binomial_rng(latent_ypred[1:n, s], detprob[ytimes[1:n, s]]);
    // expected values
    for(i in 1:n){
      mus[i, s] = detprob[ytimes[i, s]] * latent_ypred[i, s];
    }
  }
}
